package com.VendorAccounts.VendorAuthentication;

import com.Common.*;

import com.VendorAccounts.General.GeneralModel;
import com.google.gson.*;
import com.sun.org.apache.regexp.internal.RE;

import java.security.SecureRandom;
import java.sql.*;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;

/**
 * Created by alexanderkleinhans on 6/3/17.
 */
public class VendorAuthenticationModel extends AbstractModel {

    /*
    Stage 1
    Fetch pass and hash where email address match
     */
    private String vendorLoginSQL_stage1 =
            "SELECT " +
                    "   pass_hash," +
                    "   salt," +
                    "   id," +
                    "   status " +
                    "FROM " +
                    "   accounts " +
                    "WHERE " +
                    "   email_address = ? " +
                    "AND" +
                    "   account_type = ?::account_type " +
                    "LIMIT 1";

    /*
    Stage 2
    Create session for vendor.
     */
    private String vendorLoginSQL_stage2 =
            "INSERT INTO" +
                    "   sessions " +
                    "(" +
                    "   session_key," +
                    "   account_id," +
                    "   ip_address " +
                    ") VALUES (" +
                    "?,?,?) " +
                    "ON CONFLICT (account_id, ip_address)" +
                    "DO UPDATE " +
                    "SET session_key = ?";

    /*
    Stage 3
    Fetch all features for vendor.
     */
    private String vendorLoginSQL_stage3 =
            "SELECT " +
                    "   vaa.vendor_id, " +
                    "   vf.name, " +
                    "   vfa.feature_id, " +
                    "   vfa.feature_status " +
                    "FROM " +
                    "   vendor_feature_associations vfa " +
                    "INNER JOIN " +
                    "   vendor_account_associations vaa " +
                    "ON " +
                    "   vfa.vendor_id = vaa.vendor_id " +
                    "INNER JOIN " +
                    "   vendor_features vf " +
                    "ON " +
                    "   vfa.feature_id = vf.id " +
                    "WHERE " +
                    "   vaa.account_id = ?";

    private String vendorLoginSQL_stage4 =
            "SELECT " +
                    "   first_name, " +
                    "   last_name, " +
                    "   profile_picture, " +
                    "   about_me " +
                    "FROM " +
                    "   user_account_info " +
                    "WHERE " +
                    "   account_id = ?";

    private String vendorLogoutSQL_stage1 =
            "DELETE FROM" +
                    "   sessions " +
                    "WHERE" +
                    "   session_key = ?";

    private String checkVendorSessionSQL_stage1 =
            "SELECT" +
                    " creation_timestamp" +
                    "   FROM " +
                    "sessions" +
                    "   WHERE " +
                    "session_key = ?";

    public VendorAuthenticationModel () throws Exception {}

    /**
     * Try to delete rows from the session table and return a status "success" of any rows affected.
     * Throw and exception if now rows are affected.
     *
     * 1) Parse the cookie.
     * 2) Delete the record where session_key matches.
     *
     * @param cookie
     * @return logout_status
     * @throws Exception
     */
    public String vendorLogout(
            String cookie
    ) throws Exception {
        String session_key = this.parseSessionKey(cookie);
        PreparedStatement preparedStatement = this.DAO.prepareStatement(this.vendorLogoutSQL_stage1);
        try {
            preparedStatement.setString(1, session_key);
            if (preparedStatement.executeUpdate() < 1) {
                throw new Exception("Unable to log out, unknown session key.");
            }
        } catch (Exception ex) {
            System.out.print(ex.getMessage());
            throw new Exception("Unable to log out."); // unknown reason.
        } finally {
            if (preparedStatement != null) {
                preparedStatement.close();
            }
            if (this.DAO != null) {
                this.DAO.close();
            }
        }
        return "success";
    }

    /**
     * Log the vendor account in and return the cookie for that new session.
     *
     * 1A) Fetches the pass_hash and salt for account where email_address matches and where account_type = "vendor".
     *
     * 1B) Compares the hash to hash generated by password and salt found.
     *
     * 1C) Make sure the account status is verified.
     *
     * 2) Creates a session for that account with the randomly generated session_key.
     *
     * 3) Fetch all the features for the vendor associated with that account.
     *
     * 4) Fetch all user info for that account.
     *
     * 5) Create a cookie with all features, account_id, vendor_id, and drop-downs and return it.
     *
     * @param email_address
     * @param password
     * @return cookie
     * @throws Exception
     */

    public String vendorLogin(
            String email_address,
            String password,
            String ip_address
    ) throws Exception {
        boolean is_oauth = false;
        String oauth_guid = "NO OAUTH"; // Doesn't matter.
        return this.vendorLogin(
                email_address,
                password,
                ip_address,
                is_oauth
        );
    }

    private String oauth_stage1_sql =
        "SELECT " +
                "   id " +
                "FROM " +
                "   accounts " +
                "WHERE " +
                "   email_address = ?";

    public String vendorLogin(
            String email_address, // This is sometimes the oauth_guid.
            String password,
            String ip_address,
            boolean is_oauth // Skip stage 1 if oauth is being used.
    ) throws Exception {
        PreparedStatement stage1 = null;
        PreparedStatement oauth_stage1 = null;
        ResultSet stage1Result = null;
        ResultSet oauth_stage1_result = null;
        PreparedStatement stage2 = null;
        PreparedStatement stage3 = null;
        PreparedStatement stage4 = null;
        ResultSet stage4Result = null;
        ResultSet stage3Result = null;
        try {
            // Disable auto-commit.
            this.DAO.setAutoCommit(false);
            // Create the statements.
            stage1 = this.DAO.prepareStatement(this.vendorLoginSQL_stage1);
            oauth_stage1 = this.DAO.prepareStatement(this.oauth_stage1_sql);
            stage2 = this.DAO.prepareStatement(this.vendorLoginSQL_stage2);
            stage3 = this.DAO.prepareStatement(this.vendorLoginSQL_stage3);
            /*
            Stage 1A)
             */
            int account_id = 0;
            if (!is_oauth) {
                // Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
                stage1.setString(1, email_address);
                stage1.setString(2, "vendor");
                stage1Result = stage1.executeQuery();
                String pass_hash = null;
                String salt = null;
                String account_status = null;
                while (stage1Result.next()) {
                    account_id = stage1Result.getInt("id");
                    salt = stage1Result.getString("salt");
                    pass_hash = stage1Result.getString("pass_hash");
                    account_status = stage1Result.getString("status");
                }
                if (account_id == 0) {
                    throw new VendorAuthenticationException("No matching vendor account found.");
                }
                /*
                Stage 1B)
                 */
                String hash_from_provided_password = this.getHash(password, salt);
                if (!hash_from_provided_password.equals(pass_hash)) {
                    throw new VendorAuthenticationException("Valid account found but invalid password match.");
                }
                /*
                Stage 1C)
                 */
                if (account_status.equals("email_verification_pending")) {
                    throw new VendorAuthenticationException("Sorry! This email address hasn't been verified yet.");
                }
            } else {
                oauth_stage1.setString(1, email_address);
                oauth_stage1_result = oauth_stage1.executeQuery();
                while (oauth_stage1_result.next()) {
                    account_id = oauth_stage1_result.getInt("id");
                }
                if (account_id == 0) {
                    throw new VendorAuthenticationException("Unable to log in oauth user.");
                }
            }
            /*
            Stage 2)
             */
            // Generate a session_key for thew new session.
            SecureRandom random = new SecureRandom();
            byte random_bytes[] = new byte[50];
            random.nextBytes(random_bytes);
            String session_key = new String(Base64.getEncoder().encode(random_bytes));
            // Set statement variables.
            stage2.setString(1, session_key);
            stage2.setInt(2, account_id);
            stage2.setString(3, ip_address);
            stage2.setString(4, session_key);
            stage2.execute();
            /*
            Stage 3)
             */
            stage3.setInt(1, account_id);
            stage3Result = stage3.executeQuery();
            int vendor_id = 0;
            HashMap<String , VendorFeature> stringVendorFeatureHashMap = new HashMap<String, VendorFeature>();
            while (stage3Result.next()) {
                VendorFeature vendorFeature = new VendorFeature();
                String name = null;
                name = stage3Result.getString("name");
                vendor_id = stage3Result.getInt("vendor_id");
                vendorFeature.feature_id = stage3Result.getInt("feature_id");
                vendorFeature.feature_status = stage3Result.getString("feature_status");
                vendorFeature.name = name;
                stringVendorFeatureHashMap.put(name, vendorFeature);
            }
            /*
            Stage 4)
             */
            VendorCookie vendorCookie = new VendorCookie();
            stage4 = this.DAO.prepareStatement(this.vendorLoginSQL_stage4);
            stage4.setInt(1, account_id);
            stage4Result = stage4.executeQuery();
            while (stage4Result.next()) {
                vendorCookie.first_name = stage4Result.getString("first_name");
                vendorCookie.last_name = stage4Result.getString("last_name");
                vendorCookie.about_me = stage4Result.getString("about_me");
                vendorCookie.profile_picture = stage4Result.getString("profile_picture");
            }
            /*
            Stage 5)
             */
            vendorCookie.sessionKey = session_key;
            vendorCookie.accountID = account_id;
            vendorCookie.vendorID = vendor_id;
            vendorCookie.vendorFeatures = stringVendorFeatureHashMap;
            Gson gson = new Gson();
            String cookie = gson.toJson(vendorCookie);
            cookie = gson.toJson(vendorCookie);
            // Done. Commit.
            this.DAO.commit();
            return cookie;
        } catch (VendorAuthenticationException ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            // Re-throw the exception, pass all the way back up.
            throw new VendorAuthenticationException(ex.getMessage());
        } catch (Exception ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            throw new Exception("Unable to log in vendor.");
        } finally {
            if (stage1 != null) {
                stage1.close();
            }
            if (stage1Result != null) {
                stage1Result.close();
            }
            if (oauth_stage1 != null)  {
                oauth_stage1.close();
            }
            if (oauth_stage1_result != null) {
                oauth_stage1_result.close();
            }
            if (stage2 != null) {
                stage2.close();
            }
            if (stage3 != null) {
                stage3.close();
            }
            if (stage3Result != null) {
                stage3Result.close();
            }
            if (stage4 != null) {
                stage4.close();
            }
            if (stage4Result != null) {
                stage4Result.close();
            }
            if (this.DAO != null) {
                this.DAO.close();
            }
        }
    }

    /**
     * Checks the session and returns the timestamp of the session based on a
     * session-key if it exists. If not, throws an exception.
     *
     * @param session_key
     * @return timestamp
     * @throws Exception
     */
    public String checkVendorSession (
            String session_key
    ) throws Exception {
        PreparedStatement stage1 = null;
        ResultSet resultSet = null;
        try {
            stage1 = this.DAO.prepareStatement(this.checkVendorSessionSQL_stage1);
            stage1.setString(1, session_key);
            resultSet = stage1.executeQuery();
            String creation_timestamp = null;
            while (resultSet.next()) {
                creation_timestamp = resultSet.getString("creation_timestamp");
            }
            if (creation_timestamp == null) {
                // No results found.
                throw new Exception("No session found.");
            }
            return creation_timestamp;
        } catch (Exception ex) {
            System.out.println(ex);
            throw new Exception("Unable to check session.");
        } finally {
            if (stage1 != null) {
                stage1.close();
            }
            if (resultSet != null) {
                resultSet.close();
            }
            if (this.DAO != null) {
                this.DAO.close();
            }
        }
    }

}
