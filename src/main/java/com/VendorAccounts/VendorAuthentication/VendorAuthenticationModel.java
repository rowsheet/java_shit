package com.VendorAccounts.VendorAuthentication;

import com.Common.AbstractModel;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Base64;
import java.security.SecureRandom;

/**
 * Created by alexanderkleinhans on 6/3/17.
 */
public class VendorAuthenticationModel extends AbstractModel {

    private String vendorLoginSQL_stage1 =
            "SELECT " +
                    "   pass_hash," +
                    "   salt," +
                    "   id " +
                    "FROM " +
                    "   accounts " +
                    "WHERE " +
                    "   email_address = ? " +
                    "AND" +
                    "   account_type = ?::account_type " +
                    "LIMIT 1";

    private String vendorLoginSQL_stage2 =
            "INSERT INTO" +
                    "   sessions " +
                    "(" +
                    "   cookie," +
                    "   account_id" +
                    ") VALUES (" +
                    "?,?)";

    public VendorAuthenticationModel() throws Exception {}

    /**
     * Log the vendor account in and return the cookie for that new session.
     *
     * 1) Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
     *
     * 2) Compares the hash to hash generated by password and salt found.
     *
     * 3) Fetch all the features for the vendor associated with that account.
     *
     * 4) Create a REST cookie with all features, account_id, and vendor_id and return it.
     *
     * @param email_address
     * @param password
     * @return cookie
     * @throws Exception
     */

    public String vendorLogin(
            String email_address,
            String password
    ) throws Exception {
        PreparedStatement stage1 = null;
        PreparedStatement stage2 = null;
        try {
            // Disable auto-commit.
            this.DAO.setAutoCommit(false);
            // Create the statements.
            stage1 = this.DAO.prepareStatement(this.vendorLoginSQL_stage1);
            stage2 = this.DAO.prepareStatement(this.vendorLoginSQL_stage2);
            // 1) Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
            stage1.setString(1, email_address);
            stage1.setString(2, "vendor");
            ResultSet stage1Result = stage1.executeQuery();
            String pass_hash = null;
            String salt = null;
            int account_id = 0;
            while (stage1Result.next()) {
                account_id = stage1Result.getInt("id");
                salt = stage1Result.getString("salt");
                pass_hash = stage1Result.getString("pass_hash");
            }
            if (account_id == 0) {
                throw new VendorAuthenticationException("No matching vendor account found.");
            }
            // 2) Compares the hash to hash generated by password and salt found.
            String hash_from_provided_password = this.getHash(password, salt);
            if (!hash_from_provided_password.equals(pass_hash)) {
                throw new VendorAuthenticationException("Valid account found but invalid password match.");
            }
            // 3) Creates a session for that account, returning the randomly generated cookie.
            // Generate a cookie for thew new session.
            SecureRandom random = new SecureRandom();
            byte random_bytes[] = new byte[50];
            random.nextBytes(random_bytes);
            String cookie = new String(Base64.getEncoder().encode(random_bytes));
            // Set statement variables.
            stage2.setString(1, cookie);
            stage2.setInt(2, account_id);
            stage2.execute();
            return cookie;
        } catch (VendorAuthenticationException ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            // Re-throw the exception, pass all the way back up.
            throw new VendorAuthenticationException(ex.getMessage());
        } catch (Exception ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            // Unknown reason of what went wrong.
            throw new Exception("Unable to log in vendor.");
        } finally {
            if (stage1 != null) { stage1 = null; }
            if (stage2 != null) { stage2 = null; }
            this.DAO.setAutoCommit(true);
        }
    }

}
