package com.VendorAccounts.VendorAuthentication;

import com.Common.AbstractModel;
import com.Common.VendorCookie;
import com.Common.VendorFeature;

import com.google.gson.*;
import com.sun.org.apache.regexp.internal.RE;

import java.security.SecureRandom;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;

/**
 * Created by alexanderkleinhans on 6/3/17.
 */
public class VendorAuthenticationModel extends AbstractModel {

    /*
    Stage 1
    Fetch pass and hash where email address match
     */
    private String vendorLoginSQL_stage1 =
            "SELECT " +
                    "   pass_hash," +
                    "   salt," +
                    "   id," +
                    "   status " +
                    "FROM " +
                    "   accounts " +
                    "WHERE " +
                    "   email_address = ? " +
                    "AND" +
                    "   account_type = ?::account_type " +
                    "LIMIT 1";

    /*
    Stage 2
    Create session for vendor.
     */
    private String vendorLoginSQL_stage2 =
            "INSERT INTO" +
                    "   sessions " +
                    "(" +
                    "   session_key," +
                    "   account_id" +
                    ") VALUES (" +
                    "?,?) " +
                    "ON CONFLICT (account_id)" +
                    "DO UPDATE " +
                    "SET session_key = ?";

    /*
    Stage 3
    Fetch all features for vendor.
     */
    private String vendorLoginSQL_stage3 =
            "SELECT " +
                    "   vaa.vendor_id, " +
                    "   vf.name, " +
                    "   vfa.feature_id, " +
                    "   vfa.feature_status " +
                    "FROM " +
                    "   vendor_feature_associations vfa " +
                    "INNER JOIN " +
                    "   vendor_account_associations vaa " +
                    "ON " +
                    "   vfa.vendor_id = vaa.vendor_id " +
                    "INNER JOIN " +
                    "   vendor_features vf " +
                    "ON " +
                    "   vfa.feature_id = vf.id " +
                    "WHERE " +
                    "   vaa.account_id = ?";


    private String vendorLogoutSQL_stage1 =
            "DELETE FROM" +
                    "   sessions " +
                    "WHERE" +
                    "   session_key = ?";

    private String checkVendorSessionSQL_stage1 =
            "SELECT" +
                    " creation_timestamp" +
                    "   FROM " +
                    "sessions" +
                    "   WHERE " +
                    "session_key = ?";

    public VendorAuthenticationModel () throws Exception {}

    /**
     * Try to delete rows from the session table and return a status "success" of any rows affected.
     * Throw and exception if now rows are affected.
     *
     * 1) Parse the cookie.
     * 2) Delete the record where session_key matches.
     *
     * @param cookie
     * @return logout_status
     * @throws Exception
     */
    public String vendorLogout(
        String cookie
    ) throws Exception {
        String session_key = this.parseSessionKey(cookie);
        PreparedStatement preparedStatement = this.DAO.prepareStatement(this.vendorLogoutSQL_stage1);
        preparedStatement.setString(1, session_key);
        if (preparedStatement.executeUpdate() < 1) {
            throw new Exception("Unable to log out, unknown session key.");
        }
        return "success";
    }

    /**
     * Log the vendor account in and return the cookie for that new session.
     *
     * 1A) Fetches the pass_hash and salt for account where email_address matches and where account_type = "vendor".
     *
     * 1B) Compares the hash to hash generated by password and salt found.
     *
     * 1C) Make sure the account status is verified.
     *
     * 2) Creates a session for that account with the randomly generated session_key.
     *
     * 3) Fetch all the features for the vendor associated with that account.
     *
     * 4) Create a REST cookie with all features, account_id, and vendor_id and return it.
     *
     * @param email_address
     * @param password
     * @return cookie
     * @throws Exception
     */

    public String vendorLogin(
            String email_address,
            String password
    ) throws Exception {
        PreparedStatement stage1 = null;
        PreparedStatement stage2 = null;
        PreparedStatement stage3 = null;
        try {
            // Disable auto-commit.
            this.DAO.setAutoCommit(false);
            // Create the statements.
            stage1 = this.DAO.prepareStatement(this.vendorLoginSQL_stage1);
            stage2 = this.DAO.prepareStatement(this.vendorLoginSQL_stage2);
            stage3 = this.DAO.prepareStatement(this.vendorLoginSQL_stage3);
            /*
            Stage 1A)
             */
            // Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
            stage1.setString(1, email_address);
            stage1.setString(2, "vendor");
            ResultSet stage1Result = stage1.executeQuery();
            String pass_hash = null;
            String salt = null;
            int account_id = 0;
            String account_status = null;
            while (stage1Result.next()) {
                account_id = stage1Result.getInt("id");
                salt = stage1Result.getString("salt");
                pass_hash = stage1Result.getString("pass_hash");
                account_status = stage1Result.getString("status");
            }
            if (account_id == 0) {
                throw new VendorAuthenticationException("No matching vendor account found.");
            }
            /*
            Stage 1B)
             */
            String hash_from_provided_password = this.getHash(password, salt);
            if (!hash_from_provided_password.equals(pass_hash)) {
                throw new VendorAuthenticationException("Valid account found but invalid password match.");
            }
            /*
            Stage 1C)
             */
            if (account_status.equals("email_verification_pending")) {
                throw new VendorAuthenticationException("Sorry! This email address hasn't been verified yet.");
            }
            /*
            Stage 2)
             */
            // Generate a session_key for thew new session.
            SecureRandom random = new SecureRandom();
            byte random_bytes[] = new byte[50];
            random.nextBytes(random_bytes);
            String session_key = new String(Base64.getEncoder().encode(random_bytes));
            // Set statement variables.
            stage2.setString(1, session_key);
            stage2.setInt(2, account_id);
            stage2.setString(3, session_key);
            stage2.execute();
            /*
            Stage 3)
             */
            stage3.setInt(1, account_id);
            ResultSet stage3Result = stage3.executeQuery();
            int vendor_id = 0;
            HashMap<String , VendorFeature> stringVendorFeatureHashMap = new HashMap<String, VendorFeature>();
            while (stage3Result.next()) {
                VendorFeature vendorFeature = new VendorFeature();
                String name = null;
                name = stage3Result.getString("name");
                vendor_id = stage3Result.getInt("vendor_id");
                vendorFeature.feature_id = stage3Result.getInt("feature_id");
                vendorFeature.feature_status = stage3Result.getString("feature_status");
                vendorFeature.name = name;
                stringVendorFeatureHashMap.put(name, vendorFeature);
            }
            /*
            Stage 4)
             */
            VendorCookie vendorCookie = new VendorCookie();
            vendorCookie.sessionKey = session_key;
            vendorCookie.accountID = account_id;
            vendorCookie.vendorID = vendor_id;
            vendorCookie.vendorFeatures = stringVendorFeatureHashMap;
            Gson gson = new Gson();
            String cookie = gson.toJson(vendorCookie);
            return cookie;
        } catch (VendorAuthenticationException ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            // Re-throw the exception, pass all the way back up.
            throw new VendorAuthenticationException(ex.getMessage());
        } catch (Exception ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            throw new Exception("Unable to log in vendor.");
        } finally {
            if (stage1 != null) { stage1 = null; }
            if (stage2 != null) { stage2 = null; }
            this.DAO.setAutoCommit(true);
        }
    }

    /**
     * Checks the session and returns the timestamp of the session based on a
     * session-key if it exists. If not, throws an exception.
     *
     * @param session_key
     * @return
     * @throws Exception
     */
    public String checkVendorSession (
            String session_key
    ) throws Exception {
        PreparedStatement stage1 = null;
        try {
            stage1 = this.DAO.prepareStatement(this.checkVendorSessionSQL_stage1);
            stage1.setString(1, session_key);
            ResultSet resultSet = stage1.executeQuery();
            String creation_timestamp = null;
            while (resultSet.next()) {
                creation_timestamp = resultSet.getString("creation_timestamp");
            }
            if (creation_timestamp == null) {
                // No results found.
                throw new Exception("No session found.");
            }
            return creation_timestamp;
        } catch (Exception ex) {
            System.out.println(ex);
            throw new Exception("Unable to check session.");
        } finally {
            if (stage1 != null) { stage1 = null; }
        }
    }

}
