package com.VendorAccounts.VendorAuthentication;

import com.Common.AbstractModel;
import com.Common.VendorCookie;
import com.Common.VendorFeature;

import com.google.gson.*;

import java.security.SecureRandom;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;

/**
 * Created by alexanderkleinhans on 6/3/17.
 */
public class VendorAuthenticationModel extends AbstractModel {

    private String vendorLoginSQL_stage1 =
            "SELECT " +
                    "   pass_hash," +
                    "   salt," +
                    "   id " +
                    "FROM " +
                    "   accounts " +
                    "WHERE " +
                    "   email_address = ? " +
                    "AND" +
                    "   account_type = ?::account_type " +
                    "LIMIT 1";

    private String vendorLoginSQL_stage2 =
            "INSERT INTO" +
                    "   sessions " +
                    "(" +
                    "   session_id," +
                    "   account_id" +
                    ") VALUES (" +
                    "?,?)";

    private String vendorLoginSQL_stage3 =
            "SELECT " +
                    "   vaa.vendor_id, " +
                    "   vf.name, " +
                    "   vfa.feature_id, " +
                    "   vfa.feature_status " +
                    "FROM " +
                    "   vendor_feature_associations vfa " +
                    "INNER JOIN " +
                    "   vendor_account_associations vaa " +
                    "ON " +
                    "   vfa.vendor_id = vaa.vendor_id " +
                    "INNER JOIN " +
                    "   vendor_features vf " +
                    "ON " +
                    "   vfa.feature_id = vf.id " +
                    "WHERE " +
                    "   vaa.account_id = ?";


    public VendorAuthenticationModel () throws Exception {}

    /**
     * Log the vendor account in and return the cookie for that new session.
     *
     * 1A) Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
     *
     * 1B) Compares the hash to hash generated by password and salt found.
     *
     * 2) Creates a session for that account with the randomly generated session_key.
     *
     * 3) Fetch all the features for the vendor associated with that account.
     *
     * 4) Create a REST cookie with all features, account_id, and vendor_id and return it.
     *
     * @param email_address
     * @param password
     * @return cookie
     * @throws Exception
     */

    public String vendorLogin(
            String email_address,
            String password
    ) throws Exception {
        PreparedStatement stage1 = null;
        PreparedStatement stage2 = null;
        PreparedStatement stage3 = null;
        try {
            // Disable auto-commit.
            this.DAO.setAutoCommit(false);
            // Create the statements.
            stage1 = this.DAO.prepareStatement(this.vendorLoginSQL_stage1);
            stage2 = this.DAO.prepareStatement(this.vendorLoginSQL_stage2);
            stage3 = this.DAO.prepareStatement(this.vendorLoginSQL_stage3);
            /*
            Stage 1A)
             */
            // Fetches the pass_hash and salt for account where email_address matches and account_type = "vendor".
            stage1.setString(1, email_address);
            stage1.setString(2, "vendor");
            ResultSet stage1Result = stage1.executeQuery();
            String pass_hash = null;
            String salt = null;
            int account_id = 0;
            while (stage1Result.next()) {
                account_id = stage1Result.getInt("id");
                salt = stage1Result.getString("salt");
                pass_hash = stage1Result.getString("pass_hash");
            }
            if (account_id == 0) {
                throw new VendorAuthenticationException("No matching vendor account found.");
            }
            /*
            Stage 1B)
             */
            String hash_from_provided_password = this.getHash(password, salt);
            if (!hash_from_provided_password.equals(pass_hash)) {
                throw new VendorAuthenticationException("Valid account found but invalid password match.");
            }
            /*
            Stage 2)
             */
            // Generate a session_key for thew new session.
            SecureRandom random = new SecureRandom();
            byte random_bytes[] = new byte[50];
            random.nextBytes(random_bytes);
            String session_key = new String(Base64.getEncoder().encode(random_bytes));
            // Set statement variables.
            stage2.setString(1, session_key);
            stage2.setInt(2, account_id);
            stage2.execute();
            /*
            Stage 3)
             */
            stage3.setInt(1, account_id);
            ResultSet stage3Result = stage3.executeQuery();
            int vendor_id = 0;
            HashMap<String , VendorFeature> stringVendorFeatureHashMap = new HashMap<String, VendorFeature>();
            while (stage3Result.next()) {
                VendorFeature vendorFeature = new VendorFeature();
                String name = null;
                name = stage3Result.getString("name");
                vendor_id = stage3Result.getInt("vendor_id");
                vendorFeature.feature_id = stage3Result.getInt("feature_id");
                vendorFeature.feature_status = stage3Result.getString("feature_status");
                vendorFeature.name = name;
                stringVendorFeatureHashMap.put(name, vendorFeature);
            }
            /*
            Stage 4)
             */
            VendorCookie vendorCookie = new VendorCookie();
            vendorCookie.sessionKey = session_key;
            vendorCookie.accountID = account_id;
            vendorCookie.vendorID = vendor_id;
            vendorCookie.vendorFeatures = stringVendorFeatureHashMap;
            Gson gson = new Gson();
            String cookie = gson.toJson(vendorCookie);
            return cookie;
        } catch (VendorAuthenticationException ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            // Re-throw the exception, pass all the way back up.
            throw new VendorAuthenticationException(ex.getMessage());
        } catch (Exception ex) {
            // Roll back the transaction if anything has cone wrong.
            // Clean up.
            if (this.DAO != null) {
                System.out.println(ex);
                System.out.println("ROLLING BACK");
                this.DAO.rollback();
            }
            throw new Exception("Unable to log in vendor.");
        } finally {
            if (stage1 != null) { stage1 = null; }
            if (stage2 != null) { stage2 = null; }
            this.DAO.setAutoCommit(true);
        }
    }

}
